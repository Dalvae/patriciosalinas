---
interface Props {
  speed: number;
  direction: "right" | "left";
  class?: string;
}
const { speed, direction, class: className = "" } = Astro.props;
---

<div
  class={`looper ${className}`}
  data-speed={speed}
  data-direction={direction}
>
  <div class="looper__innerList" aria-hidden="true">
    <div class="looper__listInstance">
      <slot />
    </div>
    <div class="looper__listInstance">
      <slot />
    </div>
  </div>
</div>

<script>
  class InfiniteLooper {
    looper: HTMLElement;
    innerList: HTMLElement;
    listInstances: NodeListOf<HTMLElement>;
    baseSpeed: number;
    currentSpeed: number;
    targetSpeed: number;
    direction: string;
    isMouseOver: boolean;
    animationId: number | null;
    lastScrollTime: number;
    position: number;

    constructor(looper: HTMLElement) {
      this.looper = looper;
      this.innerList = this.looper.querySelector(".looper__innerList")!;
      this.listInstances = this.innerList.querySelectorAll(
        ".looper__listInstance"
      )!;
      this.baseSpeed = parseFloat(this.looper.dataset.speed || "0") * 0.05;
      this.direction = this.looper.dataset.direction || "left";
      this.currentSpeed = this.baseSpeed * (this.direction === "left" ? 1 : -1);
      this.targetSpeed = this.currentSpeed;
      this.isMouseOver = false;
      this.animationId = null;
      this.lastScrollTime = 0;
      this.position =
        this.direction === "right" ? -this.listInstances[0].offsetWidth : 0;

      this.init();
    }

    init() {
      this.addEventListeners();
      this.startAnimation();
    }

    addEventListeners() {
      this.looper.addEventListener("mouseenter", () => {
        this.isMouseOver = true;
        this.targetSpeed = 0;
      });

      this.looper.addEventListener("mouseleave", () => {
        this.isMouseOver = false;
        this.targetSpeed =
          this.baseSpeed * (this.direction === "left" ? 1 : -1);
      });

      this.looper.addEventListener("wheel", (e) => {
        e.preventDefault();
        const now = performance.now();
        if (now - this.lastScrollTime > 50) {
          this.lastScrollTime = now;
          this.isMouseOver = false;
          const scrollDirection = e.deltaY > 0 ? 1 : -1;
          const speedChange = scrollDirection * this.baseSpeed * 3;
          this.targetSpeed = Math.max(
            -this.baseSpeed * 8,
            Math.min(this.targetSpeed + speedChange, this.baseSpeed * 8)
          );
        }
      });

      window.addEventListener("resize", () => {
        this.position =
          this.direction === "right" ? -this.listInstances[0].offsetWidth : 0;
        this.startAnimation();
      });
    }

    startAnimation() {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
      this.animate();
    }

    animate() {
      this.currentSpeed += (this.targetSpeed - this.currentSpeed) * 0.1;
      this.position -= this.currentSpeed;

      const instanceWidth = this.listInstances[0].offsetWidth;

      if (this.direction === "left") {
        if (this.position <= -instanceWidth) {
          this.position += instanceWidth;
          this.innerList.appendChild(this.listInstances[0]);
          this.listInstances = this.innerList.querySelectorAll(
            ".looper__listInstance"
          )!;
        }
      } else if (this.direction === "right") {
        if (this.position >= 0) {
          this.position -= instanceWidth;
          this.innerList.prepend(
            this.listInstances[this.listInstances.length - 1]
          );
          this.listInstances = this.innerList.querySelectorAll(
            ".looper__listInstance"
          )!;
        }
      }

      this.innerList.style.transform = `translateX(${this.position}px)`;
      this.animationId = requestAnimationFrame(() => this.animate());
    }

    cleanup() {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
    }
  }

  function setupLoopers() {
    document.querySelectorAll(".looper").forEach((looperElement) => {
      const looper = new InfiniteLooper(looperElement as HTMLElement);
      (looperElement as any).__infiniteLooper = looper;
    });
  }

  document.addEventListener("astro:page-load", setupLoopers);

  document.addEventListener("astro:before-swap", () => {
    document.querySelectorAll(".looper").forEach((looperElement) => {
      const instance = (looperElement as any).__infiniteLooper;
      if (instance) {
        instance.cleanup();
      }
    });
  });

  if (document.readyState === "complete") {
    setupLoopers();
  } else {
    window.addEventListener("load", setupLoopers);
  }
</script>

<style>
  .looper {
    width: 100%;
    overflow: hidden;
  }

  .looper__innerList {
    display: flex;
    width: fit-content;
  }

  .looper__listInstance {
    display: flex;
    width: auto;
    flex-shrink: 0;
  }
</style>
